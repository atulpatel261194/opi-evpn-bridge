// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2024 Ericsson AB.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: ipsec_ipu.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	IPUIPSec_GetFeatures_FullMethodName = "/IPSecIPUInfraManager.IPUIPSec/GetFeatures"
	IPUIPSec_GetSPI_FullMethodName      = "/IPSecIPUInfraManager.IPUIPSec/GetSPI"
	IPUIPSec_AddSA_FullMethodName       = "/IPSecIPUInfraManager.IPUIPSec/AddSA"
	IPUIPSec_UpdateSA_FullMethodName    = "/IPSecIPUInfraManager.IPUIPSec/UpdateSA"
	IPUIPSec_QuerySA_FullMethodName     = "/IPSecIPUInfraManager.IPUIPSec/QuerySA"
	IPUIPSec_DeleteSA_FullMethodName    = "/IPSecIPUInfraManager.IPUIPSec/DeleteSA"
	IPUIPSec_FlushSAs_FullMethodName    = "/IPSecIPUInfraManager.IPUIPSec/FlushSAs"
)

// IPUIPSecClient is the client API for IPUIPSec service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IPUIPSecClient interface {
	// Get the feature set supported by this kernel backend.
	//
	// @return                              ORed feature-set of backend
	//
	//	kernel_feature_t (*get_features)(kernel_ipsec_t *this);
	GetFeatures(ctx context.Context, in *Features, opts ...grpc.CallOption) (*Features, error)
	// Get a SPI from the kernel.
	//
	// @param src           source address of SA
	// @param dst           destination address of SA
	// @param protocol      protocol for SA (ESP/AH)
	// @param spi           allocated spi
	// @return              SUCCESS if operation completed
	//
	//	status_t (*get_spi)(kernel_ipsec_t *this, host_t *src, host_t *dst,
	//	                                       uint8_t protocol, uint32_t *spi);
	GetSPI(ctx context.Context, in *GetSPIReq, opts ...grpc.CallOption) (*GetSPIResp, error)
	// Add an SA to the SAD.
	//
	// This function does install a single SA for a single protocol in one
	// direction.
	//
	// @param id                    data identifying this SA
	// @param data                  data for this SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*add_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                   kernel_ipsec_add_sa_t *data);
	AddSA(ctx context.Context, in *AddSAReq, opts ...grpc.CallOption) (*AddSAResp, error)
	// Update the hosts on an installed SA.
	//
	// We cannot directly update the destination address as the kernel
	// requires the spi, the protocol AND the destination address (and family)
	// to identify SAs. Therefore if the destination address changed we
	// create a new SA and delete the old one.
	//
	// @param id                    data identifying this SA
	// @param data                  updated data for this SA
	// @return                              SUCCESS if operation completed, NOT_SUPPORTED if
	//
	//	                                            the kernel interface can't update the SA
	//
	//	status_t (*update_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                           kernel_ipsec_update_sa_t *data);
	UpdateSA(ctx context.Context, in *UpdateSAReq, opts ...grpc.CallOption) (*UpdateSAResp, error)
	// Query the number of bytes processed by an SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to query the SA
	// @param[out] bytes    the number of bytes processed by SA
	// @param[out] packets  number of packets processed by SA
	// @param[out] time             last (monotonic) time of SA use
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*query_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                         kernel_ipsec_query_sa_t *data, uint64_t *bytes,
	//	                                         uint64_t *packets, time_t *time);
	QuerySA(ctx context.Context, in *QuerySAReq, opts ...grpc.CallOption) (*QuerySAResp, error)
	// Delete a previously installed SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to delete the SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*del_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                    kernel_ipsec_del_sa_t *data);
	DeleteSA(ctx context.Context, in *DeleteSAReq, opts ...grpc.CallOption) (*DeleteSAResp, error)
	// Flush all SAs from the SAD.
	//
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*flush_sas)(kernel_ipsec_t *this);
	FlushSAs(ctx context.Context, in *FlushSAsReq, opts ...grpc.CallOption) (*FlushSAsResp, error)
}

type iPUIPSecClient struct {
	cc grpc.ClientConnInterface
}

func NewIPUIPSecClient(cc grpc.ClientConnInterface) IPUIPSecClient {
	return &iPUIPSecClient{cc}
}

func (c *iPUIPSecClient) GetFeatures(ctx context.Context, in *Features, opts ...grpc.CallOption) (*Features, error) {
	out := new(Features)
	err := c.cc.Invoke(ctx, IPUIPSec_GetFeatures_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) GetSPI(ctx context.Context, in *GetSPIReq, opts ...grpc.CallOption) (*GetSPIResp, error) {
	out := new(GetSPIResp)
	err := c.cc.Invoke(ctx, IPUIPSec_GetSPI_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) AddSA(ctx context.Context, in *AddSAReq, opts ...grpc.CallOption) (*AddSAResp, error) {
	out := new(AddSAResp)
	err := c.cc.Invoke(ctx, IPUIPSec_AddSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) UpdateSA(ctx context.Context, in *UpdateSAReq, opts ...grpc.CallOption) (*UpdateSAResp, error) {
	out := new(UpdateSAResp)
	err := c.cc.Invoke(ctx, IPUIPSec_UpdateSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) QuerySA(ctx context.Context, in *QuerySAReq, opts ...grpc.CallOption) (*QuerySAResp, error) {
	out := new(QuerySAResp)
	err := c.cc.Invoke(ctx, IPUIPSec_QuerySA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) DeleteSA(ctx context.Context, in *DeleteSAReq, opts ...grpc.CallOption) (*DeleteSAResp, error) {
	out := new(DeleteSAResp)
	err := c.cc.Invoke(ctx, IPUIPSec_DeleteSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPUIPSecClient) FlushSAs(ctx context.Context, in *FlushSAsReq, opts ...grpc.CallOption) (*FlushSAsResp, error) {
	out := new(FlushSAsResp)
	err := c.cc.Invoke(ctx, IPUIPSec_FlushSAs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IPUIPSecServer is the server API for IPUIPSec service.
// All implementations must embed UnimplementedIPUIPSecServer
// for forward compatibility
type IPUIPSecServer interface {
	// Get the feature set supported by this kernel backend.
	//
	// @return                              ORed feature-set of backend
	//
	//	kernel_feature_t (*get_features)(kernel_ipsec_t *this);
	GetFeatures(context.Context, *Features) (*Features, error)
	// Get a SPI from the kernel.
	//
	// @param src           source address of SA
	// @param dst           destination address of SA
	// @param protocol      protocol for SA (ESP/AH)
	// @param spi           allocated spi
	// @return              SUCCESS if operation completed
	//
	//	status_t (*get_spi)(kernel_ipsec_t *this, host_t *src, host_t *dst,
	//	                                       uint8_t protocol, uint32_t *spi);
	GetSPI(context.Context, *GetSPIReq) (*GetSPIResp, error)
	// Add an SA to the SAD.
	//
	// This function does install a single SA for a single protocol in one
	// direction.
	//
	// @param id                    data identifying this SA
	// @param data                  data for this SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*add_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                   kernel_ipsec_add_sa_t *data);
	AddSA(context.Context, *AddSAReq) (*AddSAResp, error)
	// Update the hosts on an installed SA.
	//
	// We cannot directly update the destination address as the kernel
	// requires the spi, the protocol AND the destination address (and family)
	// to identify SAs. Therefore if the destination address changed we
	// create a new SA and delete the old one.
	//
	// @param id                    data identifying this SA
	// @param data                  updated data for this SA
	// @return                              SUCCESS if operation completed, NOT_SUPPORTED if
	//
	//	                                            the kernel interface can't update the SA
	//
	//	status_t (*update_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                           kernel_ipsec_update_sa_t *data);
	UpdateSA(context.Context, *UpdateSAReq) (*UpdateSAResp, error)
	// Query the number of bytes processed by an SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to query the SA
	// @param[out] bytes    the number of bytes processed by SA
	// @param[out] packets  number of packets processed by SA
	// @param[out] time             last (monotonic) time of SA use
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*query_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                         kernel_ipsec_query_sa_t *data, uint64_t *bytes,
	//	                                         uint64_t *packets, time_t *time);
	QuerySA(context.Context, *QuerySAReq) (*QuerySAResp, error)
	// Delete a previously installed SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to delete the SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*del_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                    kernel_ipsec_del_sa_t *data);
	DeleteSA(context.Context, *DeleteSAReq) (*DeleteSAResp, error)
	// Flush all SAs from the SAD.
	//
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*flush_sas)(kernel_ipsec_t *this);
	FlushSAs(context.Context, *FlushSAsReq) (*FlushSAsResp, error)
	mustEmbedUnimplementedIPUIPSecServer()
}

// UnimplementedIPUIPSecServer must be embedded to have forward compatible implementations.
type UnimplementedIPUIPSecServer struct {
}

func (UnimplementedIPUIPSecServer) GetFeatures(context.Context, *Features) (*Features, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeatures not implemented")
}
func (UnimplementedIPUIPSecServer) GetSPI(context.Context, *GetSPIReq) (*GetSPIResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSPI not implemented")
}
func (UnimplementedIPUIPSecServer) AddSA(context.Context, *AddSAReq) (*AddSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSA not implemented")
}
func (UnimplementedIPUIPSecServer) UpdateSA(context.Context, *UpdateSAReq) (*UpdateSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSA not implemented")
}
func (UnimplementedIPUIPSecServer) QuerySA(context.Context, *QuerySAReq) (*QuerySAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySA not implemented")
}
func (UnimplementedIPUIPSecServer) DeleteSA(context.Context, *DeleteSAReq) (*DeleteSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSA not implemented")
}
func (UnimplementedIPUIPSecServer) FlushSAs(context.Context, *FlushSAsReq) (*FlushSAsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushSAs not implemented")
}
func (UnimplementedIPUIPSecServer) mustEmbedUnimplementedIPUIPSecServer() {}

// UnsafeIPUIPSecServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IPUIPSecServer will
// result in compilation errors.
type UnsafeIPUIPSecServer interface {
	mustEmbedUnimplementedIPUIPSecServer()
}

func RegisterIPUIPSecServer(s grpc.ServiceRegistrar, srv IPUIPSecServer) {
	s.RegisterService(&IPUIPSec_ServiceDesc, srv)
}

func _IPUIPSec_GetFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Features)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).GetFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_GetFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).GetFeatures(ctx, req.(*Features))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_GetSPI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSPIReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).GetSPI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_GetSPI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).GetSPI(ctx, req.(*GetSPIReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_AddSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).AddSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_AddSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).AddSA(ctx, req.(*AddSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_UpdateSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).UpdateSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_UpdateSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).UpdateSA(ctx, req.(*UpdateSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_QuerySA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).QuerySA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_QuerySA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).QuerySA(ctx, req.(*QuerySAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_DeleteSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).DeleteSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_DeleteSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).DeleteSA(ctx, req.(*DeleteSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPUIPSec_FlushSAs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushSAsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPUIPSecServer).FlushSAs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPUIPSec_FlushSAs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPUIPSecServer).FlushSAs(ctx, req.(*FlushSAsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// IPUIPSec_ServiceDesc is the grpc.ServiceDesc for IPUIPSec service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IPUIPSec_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "IPSecIPUInfraManager.IPUIPSec",
	HandlerType: (*IPUIPSecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFeatures",
			Handler:    _IPUIPSec_GetFeatures_Handler,
		},
		{
			MethodName: "GetSPI",
			Handler:    _IPUIPSec_GetSPI_Handler,
		},
		{
			MethodName: "AddSA",
			Handler:    _IPUIPSec_AddSA_Handler,
		},
		{
			MethodName: "UpdateSA",
			Handler:    _IPUIPSec_UpdateSA_Handler,
		},
		{
			MethodName: "QuerySA",
			Handler:    _IPUIPSec_QuerySA_Handler,
		},
		{
			MethodName: "DeleteSA",
			Handler:    _IPUIPSec_DeleteSA_Handler,
		},
		{
			MethodName: "FlushSAs",
			Handler:    _IPUIPSec_FlushSAs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ipsec_ipu.proto",
}
