// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2022-2023 Dell Inc, or its subsidiaries.

// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	context "context"
	net "net"

	mock "github.com/stretchr/testify/mock"

	netlink "github.com/vishvananda/netlink"
)

// Netlink is an autogenerated mock type for the Netlink type
type Netlink struct {
	mock.Mock
}

type Netlink_Expecter struct {
	mock *mock.Mock
}

func (_m *Netlink) EXPECT() *Netlink_Expecter {
	return &Netlink_Expecter{mock: &_m.Mock}
}

// AddrAdd provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) AddrAdd(_a0 context.Context, _a1 netlink.Link, _a2 *netlink.Addr) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for AddrAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, *netlink.Addr) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_AddrAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddrAdd'
type Netlink_AddrAdd_Call struct {
	*mock.Call
}

// AddrAdd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 *netlink.Addr
func (_e *Netlink_Expecter) AddrAdd(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_AddrAdd_Call {
	return &Netlink_AddrAdd_Call{Call: _e.mock.On("AddrAdd", _a0, _a1, _a2)}
}

func (_c *Netlink_AddrAdd_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 *netlink.Addr)) *Netlink_AddrAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(*netlink.Addr))
	})
	return _c
}

func (_c *Netlink_AddrAdd_Call) Return(_a0 error) *Netlink_AddrAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_AddrAdd_Call) RunAndReturn(run func(context.Context, netlink.Link, *netlink.Addr) error) *Netlink_AddrAdd_Call {
	_c.Call.Return(run)
	return _c
}

// AddrDel provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) AddrDel(_a0 context.Context, _a1 netlink.Link, _a2 *netlink.Addr) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for AddrDel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, *netlink.Addr) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_AddrDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddrDel'
type Netlink_AddrDel_Call struct {
	*mock.Call
}

// AddrDel is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 *netlink.Addr
func (_e *Netlink_Expecter) AddrDel(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_AddrDel_Call {
	return &Netlink_AddrDel_Call{Call: _e.mock.On("AddrDel", _a0, _a1, _a2)}
}

func (_c *Netlink_AddrDel_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 *netlink.Addr)) *Netlink_AddrDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(*netlink.Addr))
	})
	return _c
}

func (_c *Netlink_AddrDel_Call) Return(_a0 error) *Netlink_AddrDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_AddrDel_Call) RunAndReturn(run func(context.Context, netlink.Link, *netlink.Addr) error) *Netlink_AddrDel_Call {
	_c.Call.Return(run)
	return _c
}

// AddrList provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) AddrList(_a0 context.Context, _a1 netlink.Link, _a2 int) ([]netlink.Addr, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for AddrList")
	}

	var r0 []netlink.Addr
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int) ([]netlink.Addr, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int) []netlink.Addr); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]netlink.Addr)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, netlink.Link, int) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_AddrList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddrList'
type Netlink_AddrList_Call struct {
	*mock.Call
}

// AddrList is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
func (_e *Netlink_Expecter) AddrList(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_AddrList_Call {
	return &Netlink_AddrList_Call{Call: _e.mock.On("AddrList", _a0, _a1, _a2)}
}

func (_c *Netlink_AddrList_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int)) *Netlink_AddrList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int))
	})
	return _c
}

func (_c *Netlink_AddrList_Call) Return(_a0 []netlink.Addr, _a1 error) *Netlink_AddrList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_AddrList_Call) RunAndReturn(run func(context.Context, netlink.Link, int) ([]netlink.Addr, error)) *Netlink_AddrList_Call {
	_c.Call.Return(run)
	return _c
}

// BridgeFdbAdd provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) BridgeFdbAdd(_a0 context.Context, _a1 string, _a2 string) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for BridgeFdbAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_BridgeFdbAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BridgeFdbAdd'
type Netlink_BridgeFdbAdd_Call struct {
	*mock.Call
}

// BridgeFdbAdd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 string
func (_e *Netlink_Expecter) BridgeFdbAdd(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_BridgeFdbAdd_Call {
	return &Netlink_BridgeFdbAdd_Call{Call: _e.mock.On("BridgeFdbAdd", _a0, _a1, _a2)}
}

func (_c *Netlink_BridgeFdbAdd_Call) Run(run func(_a0 context.Context, _a1 string, _a2 string)) *Netlink_BridgeFdbAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Netlink_BridgeFdbAdd_Call) Return(_a0 error) *Netlink_BridgeFdbAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_BridgeFdbAdd_Call) RunAndReturn(run func(context.Context, string, string) error) *Netlink_BridgeFdbAdd_Call {
	_c.Call.Return(run)
	return _c
}

// BridgeVlanAdd provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *Netlink) BridgeVlanAdd(_a0 context.Context, _a1 netlink.Link, _a2 uint16, _a3 bool, _a4 bool, _a5 bool, _a6 bool) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for BridgeVlanAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, uint16, bool, bool, bool, bool) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_BridgeVlanAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BridgeVlanAdd'
type Netlink_BridgeVlanAdd_Call struct {
	*mock.Call
}

// BridgeVlanAdd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 uint16
//   - _a3 bool
//   - _a4 bool
//   - _a5 bool
//   - _a6 bool
func (_e *Netlink_Expecter) BridgeVlanAdd(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}, _a4 interface{}, _a5 interface{}, _a6 interface{}) *Netlink_BridgeVlanAdd_Call {
	return &Netlink_BridgeVlanAdd_Call{Call: _e.mock.On("BridgeVlanAdd", _a0, _a1, _a2, _a3, _a4, _a5, _a6)}
}

func (_c *Netlink_BridgeVlanAdd_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 uint16, _a3 bool, _a4 bool, _a5 bool, _a6 bool)) *Netlink_BridgeVlanAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(uint16), args[3].(bool), args[4].(bool), args[5].(bool), args[6].(bool))
	})
	return _c
}

func (_c *Netlink_BridgeVlanAdd_Call) Return(_a0 error) *Netlink_BridgeVlanAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_BridgeVlanAdd_Call) RunAndReturn(run func(context.Context, netlink.Link, uint16, bool, bool, bool, bool) error) *Netlink_BridgeVlanAdd_Call {
	_c.Call.Return(run)
	return _c
}

// BridgeVlanDel provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *Netlink) BridgeVlanDel(_a0 context.Context, _a1 netlink.Link, _a2 uint16, _a3 bool, _a4 bool, _a5 bool, _a6 bool) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	if len(ret) == 0 {
		panic("no return value specified for BridgeVlanDel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, uint16, bool, bool, bool, bool) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_BridgeVlanDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BridgeVlanDel'
type Netlink_BridgeVlanDel_Call struct {
	*mock.Call
}

// BridgeVlanDel is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 uint16
//   - _a3 bool
//   - _a4 bool
//   - _a5 bool
//   - _a6 bool
func (_e *Netlink_Expecter) BridgeVlanDel(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}, _a4 interface{}, _a5 interface{}, _a6 interface{}) *Netlink_BridgeVlanDel_Call {
	return &Netlink_BridgeVlanDel_Call{Call: _e.mock.On("BridgeVlanDel", _a0, _a1, _a2, _a3, _a4, _a5, _a6)}
}

func (_c *Netlink_BridgeVlanDel_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 uint16, _a3 bool, _a4 bool, _a5 bool, _a6 bool)) *Netlink_BridgeVlanDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(uint16), args[3].(bool), args[4].(bool), args[5].(bool), args[6].(bool))
	})
	return _c
}

func (_c *Netlink_BridgeVlanDel_Call) Return(_a0 error) *Netlink_BridgeVlanDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_BridgeVlanDel_Call) RunAndReturn(run func(context.Context, netlink.Link, uint16, bool, bool, bool, bool) error) *Netlink_BridgeVlanDel_Call {
	_c.Call.Return(run)
	return _c
}

// LinkAdd provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkAdd(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkAdd'
type Netlink_LinkAdd_Call struct {
	*mock.Call
}

// LinkAdd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkAdd(_a0 interface{}, _a1 interface{}) *Netlink_LinkAdd_Call {
	return &Netlink_LinkAdd_Call{Call: _e.mock.On("LinkAdd", _a0, _a1)}
}

func (_c *Netlink_LinkAdd_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkAdd_Call) Return(_a0 error) *Netlink_LinkAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkAdd_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkAdd_Call {
	_c.Call.Return(run)
	return _c
}

// LinkByName provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkByName(_a0 context.Context, _a1 string) (netlink.Link, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkByName")
	}

	var r0 netlink.Link
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (netlink.Link, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) netlink.Link); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(netlink.Link)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_LinkByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkByName'
type Netlink_LinkByName_Call struct {
	*mock.Call
}

// LinkByName is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *Netlink_Expecter) LinkByName(_a0 interface{}, _a1 interface{}) *Netlink_LinkByName_Call {
	return &Netlink_LinkByName_Call{Call: _e.mock.On("LinkByName", _a0, _a1)}
}

func (_c *Netlink_LinkByName_Call) Run(run func(_a0 context.Context, _a1 string)) *Netlink_LinkByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Netlink_LinkByName_Call) Return(_a0 netlink.Link, _a1 error) *Netlink_LinkByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_LinkByName_Call) RunAndReturn(run func(context.Context, string) (netlink.Link, error)) *Netlink_LinkByName_Call {
	_c.Call.Return(run)
	return _c
}

// LinkDel provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkDel(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkDel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkDel'
type Netlink_LinkDel_Call struct {
	*mock.Call
}

// LinkDel is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkDel(_a0 interface{}, _a1 interface{}) *Netlink_LinkDel_Call {
	return &Netlink_LinkDel_Call{Call: _e.mock.On("LinkDel", _a0, _a1)}
}

func (_c *Netlink_LinkDel_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkDel_Call) Return(_a0 error) *Netlink_LinkDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkDel_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkDel_Call {
	_c.Call.Return(run)
	return _c
}

// LinkModify provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkModify(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkModify")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkModify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkModify'
type Netlink_LinkModify_Call struct {
	*mock.Call
}

// LinkModify is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkModify(_a0 interface{}, _a1 interface{}) *Netlink_LinkModify_Call {
	return &Netlink_LinkModify_Call{Call: _e.mock.On("LinkModify", _a0, _a1)}
}

func (_c *Netlink_LinkModify_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkModify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkModify_Call) Return(_a0 error) *Netlink_LinkModify_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkModify_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkModify_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetBrNeighSuppress provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetBrNeighSuppress(_a0 context.Context, _a1 netlink.Link, _a2 bool) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetBrNeighSuppress")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, bool) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetBrNeighSuppress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetBrNeighSuppress'
type Netlink_LinkSetBrNeighSuppress_Call struct {
	*mock.Call
}

// LinkSetBrNeighSuppress is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 bool
func (_e *Netlink_Expecter) LinkSetBrNeighSuppress(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetBrNeighSuppress_Call {
	return &Netlink_LinkSetBrNeighSuppress_Call{Call: _e.mock.On("LinkSetBrNeighSuppress", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetBrNeighSuppress_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 bool)) *Netlink_LinkSetBrNeighSuppress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(bool))
	})
	return _c
}

func (_c *Netlink_LinkSetBrNeighSuppress_Call) Return(_a0 error) *Netlink_LinkSetBrNeighSuppress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetBrNeighSuppress_Call) RunAndReturn(run func(context.Context, netlink.Link, bool) error) *Netlink_LinkSetBrNeighSuppress_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetDown provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkSetDown(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetDown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetDown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetDown'
type Netlink_LinkSetDown_Call struct {
	*mock.Call
}

// LinkSetDown is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkSetDown(_a0 interface{}, _a1 interface{}) *Netlink_LinkSetDown_Call {
	return &Netlink_LinkSetDown_Call{Call: _e.mock.On("LinkSetDown", _a0, _a1)}
}

func (_c *Netlink_LinkSetDown_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkSetDown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkSetDown_Call) Return(_a0 error) *Netlink_LinkSetDown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetDown_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkSetDown_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetHardwareAddr provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetHardwareAddr(_a0 context.Context, _a1 netlink.Link, _a2 net.HardwareAddr) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetHardwareAddr")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, net.HardwareAddr) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetHardwareAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetHardwareAddr'
type Netlink_LinkSetHardwareAddr_Call struct {
	*mock.Call
}

// LinkSetHardwareAddr is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 net.HardwareAddr
func (_e *Netlink_Expecter) LinkSetHardwareAddr(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetHardwareAddr_Call {
	return &Netlink_LinkSetHardwareAddr_Call{Call: _e.mock.On("LinkSetHardwareAddr", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetHardwareAddr_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 net.HardwareAddr)) *Netlink_LinkSetHardwareAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(net.HardwareAddr))
	})
	return _c
}

func (_c *Netlink_LinkSetHardwareAddr_Call) Return(_a0 error) *Netlink_LinkSetHardwareAddr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetHardwareAddr_Call) RunAndReturn(run func(context.Context, netlink.Link, net.HardwareAddr) error) *Netlink_LinkSetHardwareAddr_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetMTU provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetMTU(_a0 context.Context, _a1 netlink.Link, _a2 int) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetMTU")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetMTU_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetMTU'
type Netlink_LinkSetMTU_Call struct {
	*mock.Call
}

// LinkSetMTU is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
func (_e *Netlink_Expecter) LinkSetMTU(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetMTU_Call {
	return &Netlink_LinkSetMTU_Call{Call: _e.mock.On("LinkSetMTU", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetMTU_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int)) *Netlink_LinkSetMTU_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int))
	})
	return _c
}

func (_c *Netlink_LinkSetMTU_Call) Return(_a0 error) *Netlink_LinkSetMTU_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetMTU_Call) RunAndReturn(run func(context.Context, netlink.Link, int) error) *Netlink_LinkSetMTU_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetMaster provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetMaster(_a0 context.Context, _a1 netlink.Link, _a2 netlink.Link) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetMaster")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, netlink.Link) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetMaster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetMaster'
type Netlink_LinkSetMaster_Call struct {
	*mock.Call
}

// LinkSetMaster is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 netlink.Link
func (_e *Netlink_Expecter) LinkSetMaster(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetMaster_Call {
	return &Netlink_LinkSetMaster_Call{Call: _e.mock.On("LinkSetMaster", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetMaster_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 netlink.Link)) *Netlink_LinkSetMaster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkSetMaster_Call) Return(_a0 error) *Netlink_LinkSetMaster_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetMaster_Call) RunAndReturn(run func(context.Context, netlink.Link, netlink.Link) error) *Netlink_LinkSetMaster_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetName provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetName(_a0 context.Context, _a1 netlink.Link, _a2 string) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetName")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, string) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetName'
type Netlink_LinkSetName_Call struct {
	*mock.Call
}

// LinkSetName is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 string
func (_e *Netlink_Expecter) LinkSetName(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetName_Call {
	return &Netlink_LinkSetName_Call{Call: _e.mock.On("LinkSetName", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetName_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 string)) *Netlink_LinkSetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(string))
	})
	return _c
}

func (_c *Netlink_LinkSetName_Call) Return(_a0 error) *Netlink_LinkSetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetName_Call) RunAndReturn(run func(context.Context, netlink.Link, string) error) *Netlink_LinkSetName_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetNoMaster provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkSetNoMaster(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetNoMaster")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetNoMaster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetNoMaster'
type Netlink_LinkSetNoMaster_Call struct {
	*mock.Call
}

// LinkSetNoMaster is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkSetNoMaster(_a0 interface{}, _a1 interface{}) *Netlink_LinkSetNoMaster_Call {
	return &Netlink_LinkSetNoMaster_Call{Call: _e.mock.On("LinkSetNoMaster", _a0, _a1)}
}

func (_c *Netlink_LinkSetNoMaster_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkSetNoMaster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkSetNoMaster_Call) Return(_a0 error) *Netlink_LinkSetNoMaster_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetNoMaster_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkSetNoMaster_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetNsFd provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) LinkSetNsFd(_a0 context.Context, _a1 netlink.Link, _a2 int) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetNsFd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetNsFd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetNsFd'
type Netlink_LinkSetNsFd_Call struct {
	*mock.Call
}

// LinkSetNsFd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
func (_e *Netlink_Expecter) LinkSetNsFd(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_LinkSetNsFd_Call {
	return &Netlink_LinkSetNsFd_Call{Call: _e.mock.On("LinkSetNsFd", _a0, _a1, _a2)}
}

func (_c *Netlink_LinkSetNsFd_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int)) *Netlink_LinkSetNsFd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int))
	})
	return _c
}

func (_c *Netlink_LinkSetNsFd_Call) Return(_a0 error) *Netlink_LinkSetNsFd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetNsFd_Call) RunAndReturn(run func(context.Context, netlink.Link, int) error) *Netlink_LinkSetNsFd_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetUp provides a mock function with given fields: _a0, _a1
func (_m *Netlink) LinkSetUp(_a0 context.Context, _a1 netlink.Link) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetUp")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetUp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetUp'
type Netlink_LinkSetUp_Call struct {
	*mock.Call
}

// LinkSetUp is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
func (_e *Netlink_Expecter) LinkSetUp(_a0 interface{}, _a1 interface{}) *Netlink_LinkSetUp_Call {
	return &Netlink_LinkSetUp_Call{Call: _e.mock.On("LinkSetUp", _a0, _a1)}
}

func (_c *Netlink_LinkSetUp_Call) Run(run func(_a0 context.Context, _a1 netlink.Link)) *Netlink_LinkSetUp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link))
	})
	return _c
}

func (_c *Netlink_LinkSetUp_Call) Return(_a0 error) *Netlink_LinkSetUp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetUp_Call) RunAndReturn(run func(context.Context, netlink.Link) error) *Netlink_LinkSetUp_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetVfHardwareAddr provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Netlink) LinkSetVfHardwareAddr(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 net.HardwareAddr) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetVfHardwareAddr")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int, net.HardwareAddr) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetVfHardwareAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetVfHardwareAddr'
type Netlink_LinkSetVfHardwareAddr_Call struct {
	*mock.Call
}

// LinkSetVfHardwareAddr is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
//   - _a3 net.HardwareAddr
func (_e *Netlink_Expecter) LinkSetVfHardwareAddr(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *Netlink_LinkSetVfHardwareAddr_Call {
	return &Netlink_LinkSetVfHardwareAddr_Call{Call: _e.mock.On("LinkSetVfHardwareAddr", _a0, _a1, _a2, _a3)}
}

func (_c *Netlink_LinkSetVfHardwareAddr_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 net.HardwareAddr)) *Netlink_LinkSetVfHardwareAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int), args[3].(net.HardwareAddr))
	})
	return _c
}

func (_c *Netlink_LinkSetVfHardwareAddr_Call) Return(_a0 error) *Netlink_LinkSetVfHardwareAddr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetVfHardwareAddr_Call) RunAndReturn(run func(context.Context, netlink.Link, int, net.HardwareAddr) error) *Netlink_LinkSetVfHardwareAddr_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetVfRate provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *Netlink) LinkSetVfRate(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 int, _a4 int) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetVfRate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int, int, int) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetVfRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetVfRate'
type Netlink_LinkSetVfRate_Call struct {
	*mock.Call
}

// LinkSetVfRate is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
//   - _a3 int
//   - _a4 int
func (_e *Netlink_Expecter) LinkSetVfRate(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}, _a4 interface{}) *Netlink_LinkSetVfRate_Call {
	return &Netlink_LinkSetVfRate_Call{Call: _e.mock.On("LinkSetVfRate", _a0, _a1, _a2, _a3, _a4)}
}

func (_c *Netlink_LinkSetVfRate_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 int, _a4 int)) *Netlink_LinkSetVfRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *Netlink_LinkSetVfRate_Call) Return(_a0 error) *Netlink_LinkSetVfRate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetVfRate_Call) RunAndReturn(run func(context.Context, netlink.Link, int, int, int) error) *Netlink_LinkSetVfRate_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetVfSpoofchk provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Netlink) LinkSetVfSpoofchk(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 bool) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetVfSpoofchk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int, bool) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetVfSpoofchk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetVfSpoofchk'
type Netlink_LinkSetVfSpoofchk_Call struct {
	*mock.Call
}

// LinkSetVfSpoofchk is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
//   - _a3 bool
func (_e *Netlink_Expecter) LinkSetVfSpoofchk(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *Netlink_LinkSetVfSpoofchk_Call {
	return &Netlink_LinkSetVfSpoofchk_Call{Call: _e.mock.On("LinkSetVfSpoofchk", _a0, _a1, _a2, _a3)}
}

func (_c *Netlink_LinkSetVfSpoofchk_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 bool)) *Netlink_LinkSetVfSpoofchk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int), args[3].(bool))
	})
	return _c
}

func (_c *Netlink_LinkSetVfSpoofchk_Call) Return(_a0 error) *Netlink_LinkSetVfSpoofchk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetVfSpoofchk_Call) RunAndReturn(run func(context.Context, netlink.Link, int, bool) error) *Netlink_LinkSetVfSpoofchk_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetVfState provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Netlink) LinkSetVfState(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 uint32) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetVfState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int, uint32) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetVfState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetVfState'
type Netlink_LinkSetVfState_Call struct {
	*mock.Call
}

// LinkSetVfState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
//   - _a3 uint32
func (_e *Netlink_Expecter) LinkSetVfState(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *Netlink_LinkSetVfState_Call {
	return &Netlink_LinkSetVfState_Call{Call: _e.mock.On("LinkSetVfState", _a0, _a1, _a2, _a3)}
}

func (_c *Netlink_LinkSetVfState_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 uint32)) *Netlink_LinkSetVfState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int), args[3].(uint32))
	})
	return _c
}

func (_c *Netlink_LinkSetVfState_Call) Return(_a0 error) *Netlink_LinkSetVfState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetVfState_Call) RunAndReturn(run func(context.Context, netlink.Link, int, uint32) error) *Netlink_LinkSetVfState_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSetVfTrust provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Netlink) LinkSetVfTrust(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 bool) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for LinkSetVfTrust")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, netlink.Link, int, bool) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_LinkSetVfTrust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSetVfTrust'
type Netlink_LinkSetVfTrust_Call struct {
	*mock.Call
}

// LinkSetVfTrust is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 netlink.Link
//   - _a2 int
//   - _a3 bool
func (_e *Netlink_Expecter) LinkSetVfTrust(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *Netlink_LinkSetVfTrust_Call {
	return &Netlink_LinkSetVfTrust_Call{Call: _e.mock.On("LinkSetVfTrust", _a0, _a1, _a2, _a3)}
}

func (_c *Netlink_LinkSetVfTrust_Call) Run(run func(_a0 context.Context, _a1 netlink.Link, _a2 int, _a3 bool)) *Netlink_LinkSetVfTrust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(netlink.Link), args[2].(int), args[3].(bool))
	})
	return _c
}

func (_c *Netlink_LinkSetVfTrust_Call) Return(_a0 error) *Netlink_LinkSetVfTrust_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_LinkSetVfTrust_Call) RunAndReturn(run func(context.Context, netlink.Link, int, bool) error) *Netlink_LinkSetVfTrust_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFDB provides a mock function with given fields: _a0
func (_m *Netlink) ReadFDB(_a0 context.Context) (string, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ReadFDB")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_ReadFDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFDB'
type Netlink_ReadFDB_Call struct {
	*mock.Call
}

// ReadFDB is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *Netlink_Expecter) ReadFDB(_a0 interface{}) *Netlink_ReadFDB_Call {
	return &Netlink_ReadFDB_Call{Call: _e.mock.On("ReadFDB", _a0)}
}

func (_c *Netlink_ReadFDB_Call) Run(run func(_a0 context.Context)) *Netlink_ReadFDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Netlink_ReadFDB_Call) Return(_a0 string, _a1 error) *Netlink_ReadFDB_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_ReadFDB_Call) RunAndReturn(run func(context.Context) (string, error)) *Netlink_ReadFDB_Call {
	_c.Call.Return(run)
	return _c
}

// ReadNeigh provides a mock function with given fields: _a0, _a1
func (_m *Netlink) ReadNeigh(_a0 context.Context, _a1 string) (string, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ReadNeigh")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_ReadNeigh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadNeigh'
type Netlink_ReadNeigh_Call struct {
	*mock.Call
}

// ReadNeigh is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *Netlink_Expecter) ReadNeigh(_a0 interface{}, _a1 interface{}) *Netlink_ReadNeigh_Call {
	return &Netlink_ReadNeigh_Call{Call: _e.mock.On("ReadNeigh", _a0, _a1)}
}

func (_c *Netlink_ReadNeigh_Call) Run(run func(_a0 context.Context, _a1 string)) *Netlink_ReadNeigh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Netlink_ReadNeigh_Call) Return(_a0 string, _a1 error) *Netlink_ReadNeigh_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_ReadNeigh_Call) RunAndReturn(run func(context.Context, string) (string, error)) *Netlink_ReadNeigh_Call {
	_c.Call.Return(run)
	return _c
}

// ReadRoute provides a mock function with given fields: _a0, _a1
func (_m *Netlink) ReadRoute(_a0 context.Context, _a1 string) (string, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ReadRoute")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_ReadRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadRoute'
type Netlink_ReadRoute_Call struct {
	*mock.Call
}

// ReadRoute is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *Netlink_Expecter) ReadRoute(_a0 interface{}, _a1 interface{}) *Netlink_ReadRoute_Call {
	return &Netlink_ReadRoute_Call{Call: _e.mock.On("ReadRoute", _a0, _a1)}
}

func (_c *Netlink_ReadRoute_Call) Run(run func(_a0 context.Context, _a1 string)) *Netlink_ReadRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Netlink_ReadRoute_Call) Return(_a0 string, _a1 error) *Netlink_ReadRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_ReadRoute_Call) RunAndReturn(run func(context.Context, string) (string, error)) *Netlink_ReadRoute_Call {
	_c.Call.Return(run)
	return _c
}

// RouteAdd provides a mock function with given fields: _a0, _a1
func (_m *Netlink) RouteAdd(_a0 context.Context, _a1 *netlink.Route) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RouteAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *netlink.Route) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_RouteAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouteAdd'
type Netlink_RouteAdd_Call struct {
	*mock.Call
}

// RouteAdd is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *netlink.Route
func (_e *Netlink_Expecter) RouteAdd(_a0 interface{}, _a1 interface{}) *Netlink_RouteAdd_Call {
	return &Netlink_RouteAdd_Call{Call: _e.mock.On("RouteAdd", _a0, _a1)}
}

func (_c *Netlink_RouteAdd_Call) Run(run func(_a0 context.Context, _a1 *netlink.Route)) *Netlink_RouteAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*netlink.Route))
	})
	return _c
}

func (_c *Netlink_RouteAdd_Call) Return(_a0 error) *Netlink_RouteAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_RouteAdd_Call) RunAndReturn(run func(context.Context, *netlink.Route) error) *Netlink_RouteAdd_Call {
	_c.Call.Return(run)
	return _c
}

// RouteFlushTable provides a mock function with given fields: _a0, _a1
func (_m *Netlink) RouteFlushTable(_a0 context.Context, _a1 string) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RouteFlushTable")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Netlink_RouteFlushTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouteFlushTable'
type Netlink_RouteFlushTable_Call struct {
	*mock.Call
}

// RouteFlushTable is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *Netlink_Expecter) RouteFlushTable(_a0 interface{}, _a1 interface{}) *Netlink_RouteFlushTable_Call {
	return &Netlink_RouteFlushTable_Call{Call: _e.mock.On("RouteFlushTable", _a0, _a1)}
}

func (_c *Netlink_RouteFlushTable_Call) Run(run func(_a0 context.Context, _a1 string)) *Netlink_RouteFlushTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Netlink_RouteFlushTable_Call) Return(_a0 error) *Netlink_RouteFlushTable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_RouteFlushTable_Call) RunAndReturn(run func(context.Context, string) error) *Netlink_RouteFlushTable_Call {
	_c.Call.Return(run)
	return _c
}

// RouteListFiltered provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Netlink) RouteListFiltered(_a0 context.Context, _a1 int, _a2 *netlink.Route, _a3 uint64) ([]netlink.Route, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for RouteListFiltered")
	}

	var r0 []netlink.Route
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, *netlink.Route, uint64) ([]netlink.Route, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, *netlink.Route, uint64) []netlink.Route); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]netlink.Route)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, *netlink.Route, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_RouteListFiltered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouteListFiltered'
type Netlink_RouteListFiltered_Call struct {
	*mock.Call
}

// RouteListFiltered is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 int
//   - _a2 *netlink.Route
//   - _a3 uint64
func (_e *Netlink_Expecter) RouteListFiltered(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *Netlink_RouteListFiltered_Call {
	return &Netlink_RouteListFiltered_Call{Call: _e.mock.On("RouteListFiltered", _a0, _a1, _a2, _a3)}
}

func (_c *Netlink_RouteListFiltered_Call) Run(run func(_a0 context.Context, _a1 int, _a2 *netlink.Route, _a3 uint64)) *Netlink_RouteListFiltered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*netlink.Route), args[3].(uint64))
	})
	return _c
}

func (_c *Netlink_RouteListFiltered_Call) Return(_a0 []netlink.Route, _a1 error) *Netlink_RouteListFiltered_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_RouteListFiltered_Call) RunAndReturn(run func(context.Context, int, *netlink.Route, uint64) ([]netlink.Route, error)) *Netlink_RouteListFiltered_Call {
	_c.Call.Return(run)
	return _c
}

// RouteListIPTable provides a mock function with given fields: _a0, _a1
func (_m *Netlink) RouteListIPTable(_a0 context.Context, _a1 string) bool {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RouteListIPTable")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Netlink_RouteListIPTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouteListIPTable'
type Netlink_RouteListIPTable_Call struct {
	*mock.Call
}

// RouteListIPTable is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *Netlink_Expecter) RouteListIPTable(_a0 interface{}, _a1 interface{}) *Netlink_RouteListIPTable_Call {
	return &Netlink_RouteListIPTable_Call{Call: _e.mock.On("RouteListIPTable", _a0, _a1)}
}

func (_c *Netlink_RouteListIPTable_Call) Run(run func(_a0 context.Context, _a1 string)) *Netlink_RouteListIPTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Netlink_RouteListIPTable_Call) Return(_a0 bool) *Netlink_RouteListIPTable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Netlink_RouteListIPTable_Call) RunAndReturn(run func(context.Context, string) bool) *Netlink_RouteListIPTable_Call {
	_c.Call.Return(run)
	return _c
}

// RouteLookup provides a mock function with given fields: _a0, _a1, _a2
func (_m *Netlink) RouteLookup(_a0 context.Context, _a1 string, _a2 string) (string, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for RouteLookup")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Netlink_RouteLookup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouteLookup'
type Netlink_RouteLookup_Call struct {
	*mock.Call
}

// RouteLookup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 string
func (_e *Netlink_Expecter) RouteLookup(_a0 interface{}, _a1 interface{}, _a2 interface{}) *Netlink_RouteLookup_Call {
	return &Netlink_RouteLookup_Call{Call: _e.mock.On("RouteLookup", _a0, _a1, _a2)}
}

func (_c *Netlink_RouteLookup_Call) Run(run func(_a0 context.Context, _a1 string, _a2 string)) *Netlink_RouteLookup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Netlink_RouteLookup_Call) Return(_a0 string, _a1 error) *Netlink_RouteLookup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Netlink_RouteLookup_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *Netlink_RouteLookup_Call {
	_c.Call.Return(run)
	return _c
}

// NewNetlink creates a new instance of Netlink. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNetlink(t interface {
	mock.TestingT
	Cleanup(func())
}) *Netlink {
	mock := &Netlink{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
